# c++

## 基础

### static关键字

- 原理
  - 对于全局变量，static会修改标识符的链接属性，由默认的external变成internal，作用域和存储类型不变。
  - 对于局部变量，static会修改标识符的存储类型，由自动变量改为静态变量，作用域和链接属性不改变。这种变量，在第一次执行该代码块时创建该变量（对于C来说，在程序执行前就会创建)，并在程序执行的执行期间都存在。
  - 对于普通函数，static会修改函数的链接属性。静态函数只能在定义它的文件内被访问。
  - 对于类成员数据变量和成员函数，被static修饰后，它们都属于类，而不是某个对象，所有对象共享一个静态成员。注意：静态成员函数没有this指针。

- 全局静态变量

  - 实现

    在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。

  - 存储

    静态存储区，在整个程序运行期间一直存在。

  - 初始化

    未经初始化的全局静态变量会被自动初始化为0（对象的值是任意的，除非它被显示的初始化）。

  - 作用域

    全局静态变量在声明它的文件之外是不可见的，准确地说是从定义之处开始了，到文件结尾。

- 局部静态变量

  - 实现

    在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

  - 存储

    静态存储区。

  - 初始化

    <u>未经初始化的局部静态变量会自动的初始化0（对象的值是任意的，除非它被显示初始化）。</u>

  - 作用域

    作用域仍为局部作用域。当定义它的函数或者语句块结束时，作用域结束。但是当局部静态变量离开作用域后，并没有被销毁，而是仍然驻留在内存中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且再次之前值不变。

- 静态函数

  - 实现

    在函数返回类型前加上static，函数就定义为静态函数。

  - 作用域
    函数的定义和声明在默认情况下都是extern的，但是静态函数只在声明它的文件中可见，不能被其他文件所用；

    函数的实现使用static修饰，那么这个函数只能在本cpp中使用，不会同其他cpp中的同名函数引起冲突；

    不要在头文件中声明static的全局函数，不要在cpp中声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件中，否则cpp内部声明都需要加上static修饰。

- 类的静态数据成员

  - 实现

    在类的成员声明前加上static修饰。

  - 作用

    类的静态成员只会存储一次，可以被所有的类对象共享，并且使用静态数据成员还不会破坏隐藏的原则。

- 类的静态成员函数

  - 实现

    在类的成员函数前加上static关键字修饰。

  - 作用

    静态成员函数和静态数据成员一样，它们都属于类的静态成员，都不属于类对象的成员；

    静态函数没有this指针，因此，对于类的静态函数可以不通过类对象进行调用，通过：<类名>::<静态成员函数名>(<参数表>)的形式调用类的静态成员函数；

    在静态成员函数中，不能直接引用类中的非静态成员，只能引用类的静态成员；

    如果静态成员函数要引用非静态成员，可以通过参数列表传入类对象，然后通过类对象引用非静态成员；

### C和C++的区别

- 设计思想

  C是面向过程的结构化编程语言，C++是面向对象的编程语言。

- 语法

  - C++具有封装、继承和多态三种特性；
  - C++相比C，增加许多类型安全的功能，比如强制类型转换；
  - C++支持范式编程，模板。

### C++中cast转换

四种类型转换分别是：static_cast，dynamic_cast，const_cast和reinterpret_cast

- const_cast

  用于将const变量转换为非const变量。

- static_cast

  用于各种隐式转换，比如非const对象转为const对象，void*转为指针等。static_cast能用于多态向上转化，如果向下转化，能转成功，但是不是安全的。

- dynamic_cast

  用于动态类型转换。只能用于含有**虚函数**的类，用于类层次间（同一继承体系）的向上和向下转型。只能**转指针或引用**。向下转化时，如果是非法的对于指针进行转化，会返回NULL，对于引用的非法转化，会抛出异常。

  - 向上转型：指的是子类向基类进行转换。
  - 向下转型：指的是基类向子类进行转换。

  在执行该语句时，它通过判断变量的运行时类型和要转换的类型是否相同来判断是否能进行向下转换。

- reinterpret_cast

  几乎什么都可以转，比如将int转为指针，可能会出问题。

- 为什么不使用C的强制转换

  C的强制转化表面上看起来什么都能转，但是转化的不够明确，不能进行错误检查，容易出错。

### 指针和引用

- 指针有自己的内存空间，而引用只是一个别名。
- 使用sizeof一个指针的得到大小是4/8，而sizeof一个引用得到则是被引用对象的大小。
- 指针可以被初始化为NULL，而引用则必须被初始化为一个对象的引用。
- 作为参数传递时，指针需要被解引用后才可以操作所指对象，而对引用的修改都会改变引用所指的对象。
- 可以由const的指针，但是没有const引用。
- 指针在使用中可以指向其他对象，但是引用在创建时就被固定，不能修改。
- 指针可以有多级指针，引用只有一级。
- 指针和引用使用自增/自减运算符的意义不一样。
- 如果返回动态分配的对象或者内存，必须使用指针，**引用可能引起内存泄露**。

### 智能指针

智能指针有四种：auto_ptr、shared_ptr、unique_ptr和weak_ptr。其中后三个是c++11支持的智能指针，auto_ptr已经被弃用。

- 为什么使用智能指针

  智能指针的作用是管理动态分配的对象的指针，防止内存泄露。经常会有忘记释放动态分配的内存的情况，这样会造成内存泄露。使用智能指针，可以在很大程度上避免这种情况，因为智能指针就是一个类，当超出类对象的作用域时，类对象会自动析构，析构函数会负责处理所持有的对象指针。所以智能指针的作用原理就是在作用域结束时，自动释放内存空间，不需要人为的手动释放。

- auto_ptr(c++98方案，已被弃用)

  **采用所有权模式**。

  ```c++
  auto_ptr<string> p1(new string("hello"));
  auto_ptr<string> p2;
  p2 = p1; //auto_ptr不会报错。
  ```

  此时不会报错，p2剥夺了p1的所有权。但是当程序运行时访问p1时将会报错。所以auto_ptr的缺点是：存在潜在内存崩溃问题。

- unique_ptr（替换auto_ptr）

  **采用所有权模式**。

  unique_ptr实现**独占式拥有**或者**严格拥有**概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免内存泄露（例如“以new创建对象后，因为异常发生而忘记调用delete”）特别有用。

  ```c++
  unique_ptr<string> p3 (new string("world"));
  unique_ptr<string> p4;
  p4 = p3;//此时会报错。
  ```

  编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptrr比auto_ptr更安全。

  另外，unique_ptr还有更聪明的地方：当程序试图将一个unique_ptr复制给另一个时，如果unique_ptr是个临时右值，编译器允许这样做；如果源unique_ptr是一个非右值，编译器将禁止这样做，比如：

  ```c++
  unique_ptr<string> pu1(new string("hello"));
  unique_ptr<string> pu2;
  pu2 = pu1;//#1 报错
  unique_ptr<string> pu3;
  pu3 = unique_ptr<string>(new string("world")); //#2 允许
  ```

  其中**#1**会留下悬停指针pu1，这可能会导致危害。而**#2**不会留下悬停指针，因为它调用uniptr_ptr的构造函数，该构造函数创建了临时对象，该对象在其所有权转给pu3后就被销毁了。这种随情况而定的行为，使得uniptr_ptr优于允许对象复制的auto_ptr;

  **注**：如果确实想要执行类似与**#1**的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数**std::move()**，让你能够将一个unique_ptr赋值给另一个。例如：

  ```c++
  unique_ptr<string> ps2, ps1(new string("hello"));
  ps2 = std::move(ps1);
  ```

- shared_ptr

  shared_ptr实现共享式拥有概念：多个智能指针可以指向相同的对象，该对象和其相关资源会在“最后一个引用”被销毁时自动释放所管理的动态分配的对象的指针。从名字share就可以看出资源可以被多个指针共享，它使用引用计数机制来表明资源被多少个指针共享。可以通过其成员函数**use_count()**查看资源的所有者个数。除了可以通过**new**来构造，还可以通过传入auto_ptr、unique_ptr和weak_ptr来构造。当我们调用成员函数**release()**时，当前指针会释放资源所有权，引用计数减一。当计数为0时，资源就会被释放。

  shared_ptr是为了解决auto_ptr在对象所有权上的局限性（auto_ptr是独占的），在使用引用计数的机制上提供了可以共享所有权的智能指针。

  **成员函数**：

  ​	**use_count()**：返回引用计数的个数

  ​	**unique()**：返回是否独占所有权（use_count为1）

  ​	**swap()**：交还两个shared_ptr对象（即交换所拥有的对象）

  ​	**reset()**：放弃内部对象的所有权或拥有对象的变更，会引起原有对象的	引用计数减少。

  ​	**get()**：返回内部指针，由于已经重载了**()**方法，因此和直接使用对象是一样的。如：

  ```c++
  shared_ptr<int> sp(new int(1));
  //sp 和 sp.get()是等价的
  ```

- weak_ptr

  weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象。进行该对象的内存管理的是那个强引用的shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr设计的目的是为了配合shared_ptr而引人的一种智能指针来协助shared_ptr工作，它只可以从一个shared_ptr或另外一个weak_ptr对象构造，它的构造和析构不会引用引用计数的增加和减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题：如果两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能减为0，资源永远不会释放。weak_ptr是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给weak_ptr，它可以通过调用lock函数来获取shared_ptr。

  ```c++
  class B;
  
  class A
  {
  public:
      shared_ptr<B> pb_;
      ~A()
      {
          cout << "A destructor" << "\n";
      }
  };
  
  class B
  {
  public:
      shared_ptr<A> pa_;
      ~B
      {
          cout << "B destructor" << "\n";
      }
  };
  
  void fun()
  {
      shared_ptr<B> pb(new B());
      shared_ptr<A> pa(new A());
      pb->pa_ = pa;
      pa->pb_ = pb;
      
      cout << pb.use_count() << "\n";
      cout << pa.use_count() << "\n";
  }
  
  int main()
  {
      fun();
      return 0;
  }
  ```

  可以看到fun函数中pa，pb相互引用，两个资源的引用计数都是2，当要跳出函数时，智能指针pa，pb析构时，两个资源的引用计数会减一，但是两者的引用计数还是1，导致跳出函数时资源没有被释放掉（A、B的析构函数没有执行），如果把其中一个改为weak_ptr就可以避免这样的情况了。我们把**class A**中的shared_ptr pb_ 改成weak_ptr pb_: 这样的话，资源B一开始的引用计数就只有1，当 pb 析构时，B的引用计数变为0，B得到释放，B释放的同时也会使A的引用计数减一，同时pa的析构也会使A的引用计数减一，那么A的计数为0，A得到释放。

  **注意**：我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法**print()**，我们不能这样访问 pa->pb->print(); 因为pb是一个weak_ptr，应该先把它转化为shared_ptr，如：

  ```c++
  shared_ptr<B> p = pa->pb_.lock();
  p->print();
  ```

### 数组和指针

指针和数组的主要区别如下：

| 指针                                                         | 数组                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| 存储的是地址                                                 | 存储的是数据                         |
| 间接访问数据，首先获得指针指向的地址，然后从该地址中读取数据 | 直接访问数据                         |
| 通常用于动态的数据结构                                       | 通常用于固定数据且数据类型相同的元素 |
| 通过malloc分配内存                                           | 隐式的分配和删除                     |
| 通常指向匿名数据，操作匿名数据                               | 自身即为数据名                       |

### 野指针

野指针就是指向一个已经被删除的对象或者未申请访问受限内存区域的指针。