## 基本结构

C++ 中内存模型与所有的对象和内存位置有关。

在一个 `C++` 程序中，所有的数据都是由对象构成。“对象”仅仅是对 `C++` 数据构建块的一个声明。 `C++` 标准定义类对象为“存储区域”，但对象还是可以将自己的特性赋予其他对象，比如类型和生命周期。

### 内存屏障

为了防止编译器的指令重排和 CPU 的乱序执行，使得程序执行时对存储器的访问顺序（变量）和书写程序时的访问顺序不一致而提出的一种解决办法。也就是说，由于编译器和硬件的不正确优化，导致对内存的写入操作不能及时的反应出来，可能出现完成对内存的写入操作后，读出来的仍然可能时旧值。

- 编译器引起的内存屏障

CPU 执行时，从寄存器中读取一个数比从内存中要快的多，所有有时编译器为了编译出性能更好的程序会进行优化，就会把一些长于数据放到寄存器中，下次使用该数据时直接从寄存器中读取，而不是从内存中。

如果其他线程把内存中的数据修改了，这时候就会出现问题。

- 缓存引起的内存屏障

CPU 从内存中读取数据很慢，但是 CPU 中的寄存器的数量又很有限，为了弥补这种速度的差异，计算机引入了缓存（Cache），CPU 读取数据时会先将数据放到一个叫做 Cache 的地方，然后下次取数据时先直接访问 Cache，如果在 Cache 中命中了数据，就直接使用 Cache 中的数据，而不是再从内存中读取。同样，写入数据时，也是先将数据写入 Cache，然后等到一个特定的时间点，将 Cache 中的数据更新到内存中去。

在多 CPU 的情况下，每个 CPU 都有自己的缓存，当同一个内存区域在多个 CPU 的 Cache 中时， CPU1 改变了自己 Cache 中的值，但是 CPU2 仍然在读取自己 Cache 中的那个旧值，这样也会出现数据不一致。

- 乱序执行引起的内存屏障

超标量处理器指的是一个 CPU 拥有多条独立流水线，一次可以发射多条指令，因此很多指令的执行时乱序的。

比如，指令1 给某个内存赋值，指令2 从该内存取值，可能会出现指令2 先执行。



### C++ 内存模型

C++ 内存模式可以被看作是 C++ 程序和计算机系统（包括编译器，多核 CPU 等可能对程序进行乱序优化的软硬件）之间的契约，它规定了多线程访问同一个内存区域时的语义，以及某个线程对内存地址的更新何时能呗其他线程看见。这个模型约定：**没有数据竞争的程序时遵循顺序一致性的**。该模型的核心思想就是由程序员用同步原语（锁或者 atomic 原子类型）来保证你的程序是没有数据竞争的，这样 CPU 和编译器就会保证程序是按照程序员所想的那样执行。换句话说，程序员只需要恰当的使用具有同步语义的指令来标记那些真正需要同步的变量和操作，就相当于告诉 CPU 和编译器不要对这些标记好的同步操作和变量作违反一致性的优化，而其它未被标记的地方可以做原有的优化。

### 原子类型

原子类型具有两个新的属性：**原子性** 和 **顺序性**：

- 原子性：原子类型的操作都是不可分割的，原子的。
- 顺序性：指对该变量的操作何时对其它线程可见。

原子类型默认的顺序性都是**顺序一致性**。

### 多核 CPU 的同步和可见性

#### 同步(synchronization)

**同步**是用来保护代码块同一时间只能被一个线程执，这样可以避免数据竞争。

#### 可见性

![cpu-architecture](F:\Git\programming_language\cpp\笔记\内存模型.assets\cpu-architecture.png)

对于多核 CPU 架构来说，每个核心都有自己的 L1 缓存和 L2 缓存，然后共享着 L3 缓存。运行一段多线程代码，假如在核心1编辑更新了一个共享变量，此时该共享变量会被拷贝到核心1的 L1 缓存中。如果运行在另一个核心上的线程也要用到这个共享变量，那么此时就会出现问题。考虑现在的情况，由于核心1编辑更新了共享变量，更新后的值还没有更新到主存储中，而是存储在核心1的 L1 缓存中，这时，运行在核心2上的线程如果要读取共享变量时，应该直接从核心1的 L1 缓存中读取该变量的最新值，而不是直接从主存储中读取。这需要一种手段告诉核心 2 从核心 1 的 L1 缓存中读取最新值。

这种手段就是**可见性**。**可见性**就是通知 CPU 其他核心的缓存，变量已经被 CPU 的一个核心修改并写入到该核心的缓存中。

如果对一个变量的写入是可见的，则该变量是可见的，这意味着对该变量进行读取将返回正确的值。所以同步写，即在同步块中进行的所有变量修改，都是可见的。

#### 读写顺序

多核 CPU 带来的问题就是，同一份数据可能被存储在多个地方--主存和每个核心的缓存中。对变量的读写又有可能同时发生，这和过去的在单核 CPU 中的情况不同。一个给定的变量被存储在不同的地方，不同的线程操作该变量时，需要正确的读写该变量。

**可见性** 意味着一个读操作需要返回最后一次写入的值。那么如何确定多核 CPU 的最后一次写入？假如能给我们一条时间线，然后所有的读写都按照这条时间线进行，那么我们就能正确的读写变量的值。可惜的是，CPU 并不提供这样的功能，所有我们没有这样的工具保证多核 CPU 进行正确的读写。

![img](F:\Git\programming_language\cpp\笔记\内存模型.assets\happens-before-link-example.png)

假如我们有一个单独的线程 T1 执行写入操作，这里 T1 仅仅是把 1 写入到变量 x 中。我们还有另外一个线程 T2，它在读取这个变量 x 的值，然后将读取到的值放入变量 r 中。

当代码执行时，r 的值是多少？事实上，r 的有可能是 0，也可能是 1。假如这两个操作之间没有 **先于关系** 的话，r 的值是未定的。

##### 先于关系(happens-before)

#### Synchronized-with

就是说，如果线程 A 写了变量 X，线程 B 读了变量 X，那么我们就可以说线程 A、B 间存在 synchronized-with 关系。

#### Happens-before

Happens-before 指明了哪些指令将看到那些指令的结果。

对于单线程而言，如果一个操作 A 排列在另一个操作 B 之前，那么这个操作 A happens-before B。但如果多个操作发生在一条声明中（statement），那么通常它们是没有 happens-before 关系的，因为它们是未排序的，但是**逗号表达式**是例外。

对于多线程而言，如果一个线程中的操作 A inter-thread happens-before 另一个线程中的操作 B，那么 A happens-before B。

##### Inter-thread happens-before（线程间先于）

Inter-thread happens-before 概念相对简单，并依赖 **synchronized-with** 关系：如果一个线程中的操作 A synchronized-with 另一个线程中的操作 B，那么 A inter-thread happens-before B。Inter-thread happens-before 关系具有传递性。

Inter-thread happens-before 可以与 sequenced-before 关系结合：如果 A sequenced-before B，B inter-thread happens-before C，那么 A inter-thread happens-before C。这揭示了如果你在一个线程中对数据进行了一些列操作，那么你只需要一个 synchronized-with 关系，即可使的数据对于另一个操作 C 的线程可见。

### 硬件

获取操作（acquire）强制刷新读缓冲区（丢掉其原有的内容），释放操作（release）强制刷新存储缓冲区（将其内容写入主存）。所有，一个写入操作需要有一个释放操作，读取操作需要一个获取操作。

### 内存序列选项

- 顺序一致性(sequentially consistent)

  - memory_order_seq_cst(默认内存序列)

  定义：

  1. 从单个线程的角度来看，每个线程内部的指令都是按照程序规定的顺序来执行的。
  2. 从整个多线程程序的角度来看，整个多线程程序的执行顺序是按照某种交错顺序执行的，而且是全局一致的。

  所有线程上的所有操作都遵循一个全局时钟，每当全局时钟滴答一次就有一个操作被执行。

  - 线程以源码顺序执行指令
  - 每个线程都以相同的顺序查看另一个线程的操作。

  顺序一致中，一个线程可以看到另一个线程的操作，因此也可以看到所有其他线程的操作。

  假如，我们有两个线程，线程1 和线程2，它们分别运行在两个 CPU 上，有两个初始值为 0 的全局共享变量 x 和 y:

  ```c++
  int x = y = 0;
  ```

  线程1 执行指令：

  ```c++
  x = 1;
  r1 = y;
  ```

  线程2 执行：

  ```c++
  y = 1;
  r2 = x;
  ```

  因为多线程程序交错执行的顺序是不确定的，所以有可能出现一下几种执行顺序：

  顺序1：

  `x = 1; r1 = y; y = 1; r2 = x;`

  ​	结果：`r1 == 0; r2 == 1`

  顺序2：

  `y = 1; r2 = x; x = 1; r1 = y;`

  ​	结果：`r1 == 1; r2 == 0`

  顺序3：

  `x = 1; y = 1; r1 = y; r2 = x;`

  ​	结果：`r1 == 1; r2 == 1;`

  

  顺序一致性模型的第一个约定要求线程内部的语句都是按照程序规定的顺序执行。例如，**线程 1 中的两条语句一定是 `x = 1;` 先执行，`r1 = y;` 后执行**。

  顺序一致性模型的第二个约定要求多线程**程序按照某种顺序执行，且所有的线程看到的整体执行顺序是一致的，即该多线程程序可以按照顺序 1， 顺序 2 或者 顺序 3（以及其它可能的执行顺序）执行，且线程 1 和线程 2 观察到的整个程序的执行顺序是一致的**（例如，线程 1 如果看到的真个程序的执行顺序是书顺序 1，那么线程 2 “看见”的整个程序执行书顺序也必须是顺序 1）。 

  依照顺序一致性模型，虽然这个程序还能按照其他的交错顺序执行，但是 r1 和 r2 的值却只可能出现上面三种情况，而不可能出现 r1 和 r2 同时为 0 的情况。

  顺序一致性模型虽然易于理解，但是它却对 CPU 和编译器的性能优化做了很大的限制，所以常见的多核 CPU 和编译器都没有实现顺序一致性模型。

  对于上面所说的指令，编译器可能为了隐藏一部分读操作的延迟而做了优化，形成下面的指令序列：

  线程1： `r1 = y; x = 1;`

  线程2：`r2 = x; y = 1;`

  在这种情况下，该程序如果按照如下的顺序执行的话：

  `r1 = x; y = 1; r2 = x; x = 1;`

  就会出现 r1 和 r2 都是 0 的这种违反一致性的结果。

  那么编译器为什么会做这样的乱序优化呢？因为读一个内存中而不是 Cache 中的共享变量需要较长的时钟周期，所以编译器就“自作聪明”的让读操作先执行，从而隐藏掉一些指令执行的延迟，从而提供程序的性能。但是在多核时代，编译器缺少语言级的内存模型约束，导致其可能做出违反一致性规定的多线程语义的错误优化。同样的，多核 CPU 中的写缓存也可能实施乱序优化：它会把要写入内存的值先缓存到 Cache 中，以便让写操作之后的指令先执行，进而出现违反顺序一致性的执行顺序。

  默认序列就是顺序一致性，它将程序看成是一个简单的序列。如果对于一个原子变量的操作都是顺序一致的，那么多线程程序的行为就像是这些操作都以一种特定顺序被单线程程序处理。

- 获取-释放序列

  - memory_order_consume
  - memory_order_acquire
  - memory_order_release
  - memory_order_acq_rel

  获取-释放语义中，线程间不存在全局同步：只有同一个原子上的原子操作才进行同步。比如：一个线程上的写操作与另一个线程上的读操作，只有作用于同一个原子变量时才进行同步。

  获取-释放语义的基本思想：释放操作和获取操作在同一原子上同步，并建立一个顺序。这意味着，在释放操作之后不能进行所有的读写操作，在获取操作之前不能进行所有的读写操作。

- 自由序列（松弛序列）
  - memory_order_relaxed

### 参考

[缓存连续性](https://techexpertise.medium.com/cache-coherence-problem-and-approaches-a18cdd48ee0e)

[内存读写序](https://ducmanhphan.github.io/2020-04-06-Ordering-read-write-operations-on-a-multiple-core-cpu/)

## 并发



