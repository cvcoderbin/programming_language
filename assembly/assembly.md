# 汇编

## 基础

汇编语言是机器语言的助记符，帮助人类阅读和记忆。同机器指令是一一对应的。

每种CPU都有自己的指令集。

CPU可以直接使用的信息存放在寄存器中。

存储单元从零开始顺序编号。

### 什么是寄存器

简单来说就是嵌入到cpu中的内存。

### 汇编语言的组成

- 汇编指令（机器码的助记符）
- 伪指令（由编译器执行）
- 其他符号（由编译器识别）

汇编语言的核心是汇编指令，它决定了语言的特性。

### 指令和数据

在内存和磁盘上， 指令和数据没有任何区别，都是二进制信息。

### 总线

- 地址总线
- 数据总线
- 控制总线



## 寄存器

### 8086

8086 有 14 个寄存器，分别为：

- AX
- BX
- CX
- DX
- SI
- DI
- SP
- BP
- IP
- CS
- SS
- DS
- ES
- PSW

AX， BX， CX， DX 通常用来存放一般性数据，被称为通用寄存器。

## 转移指令

### 转移指令分类

- 无条件转移指令（如：jmp）
- 条件转移指令
- 循环指令（如：loop）
- 过程
- 中断

### offset 操作符

伪指令，作用是去的标号的偏移地址





### jmp 指令

无条件跳转指令，可以只修改IP，也可以同时修改CS和IP

jmp 指令对应的机器码中并没有转移的目的地址，而是相对于当前 IP 的转移位移。

- jmp short 标号（转移到标号处执行指令） 段内短转移，对 IP 的修改范围是 -128 ~ 127 。

  jmp short 标号的功能是， （IP）= （IP）+ 8 位位移 

### 位移的 jmp 指令

还有一种和指令 "jmp short 标号" 功能相近的指令格式：jmp near ptr 标号，它实现的是段内近转移。

jmp near ptr 标号 的功能是：（IP） = （IP） +  16 位的位移。

功能：

- （cs）=标号所在段的段地址
- （IP）= 标号所在段中的偏移地址。
- far ptr 指明了指令用标号的段地址和偏移地址修改 CS 和 IP。

### 转移的目的地址在指令中的 jmp 指令

jmp far ptr 标号实现的是段间转移，又称为远转移

### 转移的目的地址在寄存器中的 jmp 指令

指令格式：jmp 16位寄存器

功能：

- （IP） = （16位寄存器）

### 转移的目的地址在内存中的 jmp 指令

指令格式：

- jmp word ptr 内存单元地址（段内转移）

  - 功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址。

- jmp dword ptr 内存单元地址（段间转移）

  - 功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址

    - （CS）=（内存单元地址+2）
    - （IP）=（内存单元地址）

    内存单元地址可用寻址方式的任意格式给出。

### jcxz 指令

有条件的转移指令，所有的有条件的转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为 -128~ 127

指令格式：

jcxz 标号（jmp cx zero，是 0 就跳转）

- 当（CX）= 0 时，（IP）= （IP）+ 8 位位移。
  - 8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址
  - 8位位移的范围是 -128~127，不嘛表示
  - 8位位移由编译程序在编译时算出。
- 当 （CX）!= 0 时，什么也不做（程序向下执行）。

### loop 指令

loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。

指令格式：

loop 标号

（CX）= （CX）- 1，如果（CS）!= 0，转移到标号处执行。 

## ret 和 call

call 和 ret 指令都是转移指令，它们都修改IP， 或者同时修改 CS 和 IP。

ret 指令使用栈中的数据，修改 IP 的内容，从而实现近转移。

CPU 执行 ret 指令时，进行下面两步操作：

1. (IP) = ((ss)*16+(sp))
2. (sp) = (sp) + 2

retf 指令使用栈中的数据，修改 CS 和 IP 中的内容，从而实现远转移。

CPU 执行 retf 指令时，进行下面四步操作：

1. (IP) = ((ss)*16 + (sp))
2. (sp) = (sp) + 2
3. (CS) = ((ss)*16 + (sp))
4. (sp) = (sp) + 2



call 指令经常跟 ret 指令配合使用，因此 CPU 执行 call 指令， 进行两步操作：

1. 将当前的 IP 或 CS 和 IP 压入栈中
2. 转移 (jmp)

call 指令不能实现短转移，除此之外，call 指令实现转移的方法和 jmp 指令的原理相同。

#### 指令格式

##### call 标号

（将当前的 IP 压栈后，转到标号处执行执行）

CPU 执行此种格式的 call 指令时，进行如下的操作：

1. (sp) = (sp) - 2 , ((ss)*16 + (sp)) = (IP)
2. (IP) = (IP) + 16 位位移 

16位位移，由标号处的地址 - call 指令后的第一个字节的地址计算得出。

##### call far ptr 标号

实现段间转移

CPU 执行此种格式的 call 指令时，进行如下的操作：

1. (sp) = (sp) - 2 , ((ss) * 16 + (sp)) = (CS), (sp) = (sp) - 2, ((ss)*16 + (sp)) = (ip)
2. (CS) = 标号所在的段地址，(IP) = 标号所在的偏移地址

相当于执行

1. push CS
2. push IP
3. jmp far ptr 标号

##### call 16 位寄存器

功能：

1. (sp) = (sp) -2
2. ((ss) * 16 + (sp)) = (IP)
3. (IP) = (16 位寄存器)

##### call 内存中的地址

###### call word ptr 内存单元地址

段内短转移

###### call dword ptr 内存单元地址

汇编语法解释；

1. push CS
2. push IP
3. jmp dword ptr 内存单元地址



